# Лабораторна робота №2 Створення RestFull Api за допомогою NestJS

## Мета: Опанування основних концепцій та паттернів розробки вебдодатків на прикладі фреймворку NestJS.

### Теоретичні відомості

**Node.js** — програмна платформа для розробки швидких і масштабованих web-додатків, клієнтська і серверна частина яких написані на JavaScript. 
Node.js використовує рушій V8 від Google та перетворює JavaScript код в бінарний, який може працювати не тільки в браузері, але також в додатках на ПК або мобільних ОС.
На практиці, Node.js застосовують як web-сервер через його подієво-орієнтовану модель та неблокуючу архітектури. 
Все це фундаментальні можливості, для використання яких у вашому проєкті, потрібні надбудови вищого рівня, такі як фреймворк Nest.JS.

**Завдання фреймворку** — зробити розробку простіше, швидше і більш структурованою. Для Node.js є понад декілька десятків популярних фреймворків, заснованих, як і Nest.JS, на «стандартному» Express.JS. 
Головна перевага Nest.JS в порівнянні з базовою платформою — чітка архітектура, що складається з трьох компонентів: 
 - контролерів; 
 - модулів;
 - провайдерів (постачальників). 
Завдяки їй додаток з самого початку розробки просто розділити на мікросервіси та працювати над кожним окремо, поєднуючи в єдину систему.

**NestJS** — фреймворк для створення серверних додатків Node.js. Це просте середовище з чіткою архітектурою і широкими можливостями, кількість користувачів якого постійно зростає.
Nest.JS створений для розробки вимогливих і нестандартних систем, містить все необхідне щоб запустити проєкт.
Підтримує інтеграцію будь-яких компонентів Express.JS, бібліотек і модулів TypeScript та JavaScript, а також багато іншого. 

[https://brander.ua/technologies/nestjs] 

## Контролери, постачальники та модулі

**Контролери** відповідають за обробку вхідних запитів і повернення відповідей клієнту.

Щоб створити базовий контролер, використовуються класи та декоратори. 
Декоратори пов’язують класи з необхідними метаданими та дозволяють Nest створювати карту маршрутизації (прив’язувати запити до відповідних контролерів).

```ts
// cats.controller.ts
import {Controller, Get} from '@nestjs/common';
import {CatsService} from "./cats.service";
import {Cat} from "./cat.interface";

@Controller('cats')
export class CatsController {
   constructor(private catsService: CatsService) {
   }

   @Get()
   async findAll(): Promise<Cat[]> {
      return this.catsService.findAll();
   }
}
```
**Постачальники (providers)** є фундаментальним поняттям у Nest. Багато базових класів Nest можуть розглядатися як постачальники – служби, репозиторії, фабрики, помічники тощо. 
Основна ідея провайдера полягає в тому, що його можна впровадити (inject) як залежність.
Це означає, що об’єкти можуть створювати різні зв’язки один з одним, а функцію «з’єднання» цих об’єктів можна значною мірою делегувати фреймворку.

Контролери повинні обробляти HTTP-запити та делегувати складніші завдання сервісам.

**Сервіс** — це звичайні класи JavaScript, які оголошуються як providers у модулі.

Наприклад, CatsService відповідатиме за зберігання й пошук даних у CatsController, тому його можна визначити як постачальника.

```ts
// cats.service.ts

import { Injectable } from '@nestjs/common';
import { Cat } from './interfaces/cat.interface';

@Injectable()
export class CatsService {
   private readonly cats: Cat[] = [];

   create(cat: Cat) {
      this.cats.push(cat);
   }

   findAll(): Cat[] {
      return this.cats;
   }
}
```

**Ін'єкція залежності** - шаблону проєктування, що відповідає за впровадження залежностей. Наприклад, ви можете впровадити сервіс в контролер, щоб використовувати його функціональність.

```ts

constructor(private catsService: CatsService) {}

```

**Модуль** — це клас, анотований декоратором @Module(). Декоратор @Module() надає метадані, які Nest використовує для організації структури програми.

![img.png](assets%2Fimg.png)

Кожна програма має принаймні один модуль - кореневий. Кореневий модуль є відправною точкою, яку Nest використовує для побудови графа додатка – внутрішньої структури даних, 
яку Nest використовує для вирішення зв’язків і залежностей між модулем і постачальником. 
Хоча дуже маленькі програми теоретично можуть мати лише кореневий модуль, це не типовий випадок. Слід підкреслити, 
що модулі рекомендуються як ефективний спосіб організації ваших компонентів. Таким чином,
для більшості додатків результуюча архітектура буде використовувати кілька модулів, кожен з яких інкапсулює тісно пов’язаний набір можливостей.
Декоратор @Module() бере один об’єкт, властивості якого описують модуль:

| Назва | Опис                                                                                                                                                                                                 |
|---|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| providers	| постачальники, екземпляри яких буде створено в Nest і які можуть спільно використовуватися принаймні в цьому модулі                                                                                  |
| controllers	| набір контролерів, визначених у цьому модулі                                                                                                                                                         |
| imports | 	список  імпортованих модулів, які експортують постачальників, необхідних у цьому модулі                                                                                                             |
| exports | постачальники яка надаються цим модулем |

Модуль інкапсулює постачальників за замовчуванням. 
Це означає, що неможливо вставити постачальників, які не є ані безпосередньо частиною поточного модуля, ані експортованими з імпортованих модулів. 
Таким чином, ви можете розглядати експортовані провайдери з модуля як публічний інтерфейс модуля або API.

Модуль об'эднуэ сутності навколо певної функціональності або домену програми. Наприклад оберемо домен Cats. 
CatsController, CatsService  тісно пов’язані між собою і є сенс тримати їх у одному модулі. 
Модуль зберігаючи код упорядкованим і допомагає керувати складністю та розвиватися за принципами SOLID, особливо коли розмір програми та/або команди зростає.

Щоб продемонструвати, створимо CatsModule:

```ts
import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import {CatsService} from "./cats.service";

@Module({
    controllers: [CatsController],
    providers: [CatsService]
})
export class CatsModule {}
```

### Завдання

1. Ознайомитися з документацією NestJS та теоретичними відомостями лабораторної роботи.
2. Створити новий проект за допомогою Nest CLI.
3. Використовуючи nest CLI Створити модулі, контролери, сервіси, для сутностей визначених у [специфікації openAPI](node-api-spec.yaml).
4. Встановити та налагодити роботу TypeORM та підключити базу даних PostgreSQL.
5. Створити необхідні TypeORM сутності (включаючи зв'язки) та реалізувати сервіси з використанням репозиторіїв.
6. Використовуючи пакет `nestjs-paginate` реалізувати пагінацію даних.
7. Реалізувати валідацію даних та обробку помилок.
8. Використовуючи пакет `nestjs-seeder` або `typeorm-seeding` заповнити базу даних тестовими даними.
9. Перевірити відповідність спеціфікації OpenAPI та реалізованого API.
10. Запустити проєкт разом с проксі-сервером та протестувати його роботу використовуючи тестовий фронтенд проєкт (необхідно виправити url в сервісах).
11. Завантажити проєкт до власного репозиторію з назвою за шаблоном `<vendor>/backend-labs-2` на GitHub/Bitbucket та надати посилання на нього в якості звіту.

**Посилань на Документацію**

| Бібліотека | Посилання на документацію                                      |
|-------------|----------------------------------------------------------------|
| TypeORM     | [Документація TypeORM](https://github.com/typeorm/typeorm)        |

### Контрольні питання

1. Що таке OpenAPI, і яку роль вона відіграє у розробці RESTful API?
2. Які кроки потрібно виконати для встановлення та налаштування Swagger (OpenAPI) в NestJS за допомогою @nestjs/swagger та swagger-ui-express?
3. Що робить декоратор @Controller в NestJS, і як він використовується для організації маршрутів?
4. Як виглядає структура базового контролера в NestJS, і як він обробляє HTTP-запити?
5. Як визначається та використовується сервіс в контролері?
6. Що таке ін'єкція залежності, і чому вона важлива в розробці за принципами SOLID?
7. Які є основні поняття та роль постачальників в NestJS?
8. Як створити та налаштувати модуль в NestJS? Які властивості декоратора @Module?
9. Як об'єднати контролер, сервіс та модуль для сутності в NestJS?
10. Що таке TypeORM, і як його підключити до проекту NestJS?
11. Як створити та використовувати міграції в TypeORM для роботи з базою даних?
12. Як використовувати репозиторій для здійснення CRUD операцій з базою даних в NestJS?

## Як користуватись цим репозиторієм

### Передумови

Для роботи з цим репозиторієм вам знадобиться встановлені на вашому комп'ютері наступні програми:

- Docker and Docker-compose
- Git 
- Node.js

### Як запустити цей проект

1. Клонуйте цей репозиторій на свій комп'ютер
2. Перейдіть у директорію frontend та виконайте команду
```bash
  npm install
```
3. Поверніться у корневу директорію та виконайте команду
```bash
  docker-compose up -d
```  
4. Зайдіть у контейнер з php та виконайте команду
```bash
  docker exec -it <php container id or name> /bin/bash
  cd /app
  composer install
```
3. Перейдіть у директорію node-app та виконайте команду
```bash
  npm install
```
5. Відкрийте ваш браузер та перейдіть за посиланням http://localhost:8000

6. Зупинити проект можна виконавши команду
```bash
  docker-compose down
``` 

## Додаткові матеріали

- https://medium.com/@abdullahirfan99_80517/mastering-database-migrations-in-nestjs-d1b586be3490
- https://mailtrap.io/

- https://chatgpt.com/c/67b4b5b3-8358-800a-bae2-998e65eec34f
- https://habr.com/ru/articles/652867/
- https://cloud.google.com/blog/topics/developers-practitioners/how-pubsub-eliminates-boring-meetings-and-makes-your-systems-scale
- https://mermaid.js.org/syntax/sequenceDiagram.html
- 
- https://mermaid.live/edit#pako:eNpVUV1vgjAU_StNn1xiE0Bl4tui2UeWKBHNsoWXSi_QCK0rrWYx_vfBHSzb47nnnHt6bq800wLogjLGUmWlrWBBUrpbxiTm2RFsSlOF3AkhO4DlqSLEY_6sUybamQxIrA1KCfFDNvE7ZgWNlYpbqdUfehKwcIJG-HSgWuva1QcwP2w4ZRGufciOSl8qEEUNyv7TRCGLIgzglpNNnjcwRHvtqzz0b6EBcwYxEGE33G-fBnyPIcvXAc87HCfPA8aAbbLrse_hk9_XA8aGjy-_OGB-gDvfpBL60o-DOfOn2HZZQnZsXN0T02l7PszYm6IrGGup7NDQD9seEUaMNqfugA3hSrQ_IoRUxV2vigIWzGa_lxiduZH8UAGpQBW2RBkd0xpMzaVo__ja2VJqS6ghpZ1RQM5dhee7tVLurE6-VEYX1jgYU6NdUdJFzqumRe4kuIWV5IXh9SA5cfWhdd2Lbt__SrDT
- https://jsonapi.org/
- https://www.geeksforgeeks.org/node-js-frameworks/
- NestJS Request Lifecycle: A Complete Guide to the Architecture https://medium.com/@daiki01240/nestjs-request-lifecycle-a-complete-guide-to-the-architecture-5ada9666867a 
